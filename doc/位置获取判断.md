## 第二阶段：位置获取和位置判断


概述：利用[HTML5](https://developer.mozilla.org/zh-CN/docs/Web/API/Geolocation/getCurrentPosition)的方式获取地理位置后，利用arcgis js地图渲染库中提供的地图显示和要素查询功能对位置进行判断。


#### 1.位置获取：HTML5的方式


**1.1 概述**


利用HTML5的方式获取地理位置比较简单，示例： 一次性获取设备当前位置的方法
​

```javascript
<script>
  navigator.geolocation.getCurrentPosition(function (positionData) {
    // 打印位置信息
    console.log(positionData); 
  });
</script>
```


**1.2 浏览器的支持情况：目前测试到的浏览器**


PC端（windows）：新版Edge（较好）、火狐（较好）


移动端（Android）：微信聊天框内置浏览器（好）、火狐（较好）、华为等手机厂商内置浏览器（较好）


体验较差或不能使用的浏览器：PC端 移动端的Chorme浏览器（不能使用）、移动端的Edge浏览器（体验较差）


**1.3 注意的点**


如果部署到公网上，想要使用HTML5的方式获取位置，需要配置HTTPS协议，即让链接是以https开头


#### 2.位置判断：使用arcgis js地图库


**2.1 概述**


[FeatureLayer](https://developers.arcgis.com/javascript/latest/api-reference/esri-layers-FeatureLayer.html)图层提供了查询相关的功能，一些其他图层也具有查询功能，本文以常见的FeatureLayer为例来使用；
​

```
1.FeatureLayer图层的创建
1.1：arcgis server、arcgis online发布服务，添加为 FeatureLayer（Map Service 或 Feature Service）
1.2：Graphic（点、线、面）转换为 FeatureLayer

2.FeatureLayer图层的样式、标注、弹窗提示相关的属性
renderer						// 样式渲染属性
labelingInfo				// 标注样式属性
popupTemplate				// 弹窗属性

3.FeatureLayer图层的查询、展示相关的方法 属性
createQuery()   		// 创建查询条件
queryFeatures()			// 要素查询
queryFeatureCount() // 要素查询到的个数
更多方法：https://developers.arcgis.com/javascript/latest/api-reference/esri-layers-FeatureLayer.html#methods-summary
```


### 一.页面创建


概述：简单创建一个以html扩展名的文件，搭建页面布局样式、引入地图库对应的CDN并初步展示地图。


#### 1.搭建页面布局样式


创建一个以html扩展名的文件，搭建页面布局样式


i：如果使用VSCode编辑器，可预先下载两个插件：Live Server、koroFileHeader；在扩展模块搜索即可。
![2-1 输入要查找的扩展名称.png](https://cdn.nlark.com/yuque/0/2021/png/22408012/1633534462773-b005cd01-3bc6-4458-9a52-ef7d220cc90c.png#clientId=u29ebb9d3-37d3-4&from=drop&id=uf343760f&margin=%5Bobject%20Object%5D&name=2-1%20%E8%BE%93%E5%85%A5%E8%A6%81%E6%9F%A5%E6%89%BE%E7%9A%84%E6%89%A9%E5%B1%95%E5%90%8D%E7%A7%B0.png&originHeight=2240&originWidth=3584&originalType=binary&ratio=1&size=701020&status=done&style=none&taskId=u88cf7ff8-4865-47b0-a3cc-cd6552cf294)


ii：在VSCode资源项目中创建一个名为“get-and-analyse-position.html”的文件，创建后默认文件内容如下，这是koroFileHeader的注释功能：


```
<!--
 * @Author: your name
 * @Date: 2021-10-05 09:43:31
 * @LastEditTime: 2021-10-05 09:43:32
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /arcgis api test/position/process/get-and-analyse-position.html
-->
```


iii：创建html基本骨架内容


在html文件中首先输入英文的"!"，然后按"tab"键，即可创建如下html骨架内容（注：将lang="en"修改为lang="zh"，浏览器翻译就不会出来提示了；将head标签内的title标签内容修改为：位置获取、位置判断，其对应标签页标题）


```html
<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>位置获取、位置判断</title>
</head>
<body>
  
</body>
</html>
```


iiii：创建地图对应的标签容器viewDiv和设置相应的样式


添加如下html标签，即viewDiv作为地图显示容器；too-bottom作为一个按钮区域


```html
<body>
  <div id="viewDiv"></div>
  <div id="tool-bottom">定位分析</div>
</body>
```


添加如下css样式，首先对html，body的宽高设置100%，使页面在浏览器上占据单页满屏位置；然后去除元素默认内边距、外边距；紧接着对地图显示容器viewDiv设置100%显示；而对于too-bottom按钮区域可设置绝对定位position:absolute;设置在地图显示容器图层之上显示。


flex布局使子元素在父元素居中设置变的简单，首先对父元素设置为display:flex;在父元素中设置上下轴和左右轴的对齐方式设置为居中即可，即设置 align-items、justify-content属性为center。


```html
<style>
  body,
  html {
    width: 100%;
    height: 100%;
  }

  body,
  html,
  div {
    margin: 0;
    padding: 0;
  }

  #viewDiv {
    width: 100%;
    height: 100%;
  }

  #tool-bottom {
    width: 100%;
    height: 10%;
    background-color: #a23;
    position: absolute;
    bottom: 0;
    left: 0;
    color: white;
    font-size: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
</style>
```


#### 2.初步显示地图


引入地图库对应的CDN并初步展示地图；使用arcgis默认提供的AMD规范以RequireJS 来实现加载易于该教程完整的介绍和尝试，而满足ES Module规范的import方式则适合未来现代前端大型项目中且配置起来比较繁琐些。


i：引入地图库对应的CDN，将CSS、JS对应的资源链接标签放到head标签内即可


```html
<link rel="stylesheet" href="https://js.arcgis.com/4.21/esri/themes/light/main.css" />
<script src="https://js.arcgis.com/4.21/"></script>
```


ii：初步显示地图


由于本文中用到arcgis中的地图Map、MapView模块，还用到Graphic、FeatureLayer模块，所以首先将它们引入进来；


在Map中，地图底图选用了gray-vector;即basemap: "gray-vector"，这里地图也可选择高清遥感影像底图: "hybrid"；


在MapView中，设置了对应的地图容器、初始位置、缩放等级等。


```javascript
require([
  "esri/Map",
  "esri/Graphic",
  "esri/views/MapView",
  "esri/layers/FeatureLayer"
], (Map, Graphic, MapView, FeatureLayer) => {
  const map = new Map({
    basemap: "gray-vector",
  });

  const view = new MapView({
    container: "viewDiv",
    map: map,
    center: [116.026835445288, 28.68327087208513],
    zoom: 15
  });
});
```


#### 3.基本的页面创建完整代码


```html
<!--
 * @Author: your name
 * @Date: 2021-10-05 09:43:31
 * @LastEditTime: 2021-10-05 10:33:29
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /arcgis api test/position/process/get-and-analyse-position.html
-->

<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>位置获取、位置判断</title>
  <link rel="stylesheet" href="https://js.arcgis.com/4.21/esri/themes/light/main.css" />
  <script src="https://js.arcgis.com/4.21/"></script>
  <style>
    body,
    html {
      width: 100%;
      height: 100%;
    }

    body,
    html,
    div {
      margin: 0;
      padding: 0;
    }

    #viewDiv {
      width: 100%;
      height: 100%;
    }

    #tool-bottom {
      width: 100%;
      height: 10%;
      background-color: #a23;
      position: absolute;
      bottom: 0;
      left: 0;
      color: white;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
  </style>
</head>
<body>
  <div id="viewDiv"></div>
  <div id="tool-bottom">定位分析</div>
  <script>
    require([
      "esri/Map",
      "esri/Graphic",
      "esri/views/MapView",
      "esri/layers/FeatureLayer"
    ], (Map, Graphic, MapView, FeatureLayer) => {
      const map = new Map({
        basemap: "gray-vector",
      });

      const view = new MapView({
        container: "viewDiv",
        map: map,
        center: [116.026835445288, 28.68327087208513],
        zoom: 15
      });
    });
  </script>
</body>
</html>
```
​

页面初步显示效果：
![截屏2021-10-05 上午11.23.13.png](https://cdn.nlark.com/yuque/0/2021/png/22408012/1633532264907-53166c91-7d4e-48bc-89ef-bf903aac324d.png#clientId=u633f0849-afb5-4&from=drop&id=u935925b6&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-10-05%20%E4%B8%8A%E5%8D%8811.23.13.png&originHeight=2240&originWidth=3584&originalType=binary&ratio=1&size=1478293&status=done&style=none&taskId=uf4d3ca82-6f4c-412d-948c-1215f5194f9)
在线预览：[display-map.html](https://pkcile.gitee.io/get-and-analyse-position/process/display-map.html)


### 二.位置获取和位置判断


概述：位置获取之后**紧接着**进行位置判断，也就是在位置获取得到数据后就地执行位置判断相关的函数


#### 1.位置获取及相关的解释


i：获取html对应的定位分析节点后，绑定点击事件，点击后触发该事件


```javascript
// 获取定位分析所在的html节点
const toolItemAction = document.querySelector("#tool-bottom");
// 绑定点击事件
toolItemAction.addEventListener('click', toolItemActionFunction);

// 被调用的函数
function toolItemActionFunction() {
  console.log("被调用的函数");
}
```


ii：位置获取


点击触发事件后，执行了浏览器中获取地理位置的方法，而该方法获得的地理位置数据回调在其函数内。这种情况下，地理位置数据是return不出去getPostion函数的；


```javascript
const toolItemAction = document.querySelector("#tool-bottom");
toolItemAction.addEventListener('click', toolItemActionFunction);

function toolItemActionFunction() {
  getPostion();

  function getPostion() {
    navigator.geolocation.getCurrentPosition(function (positionData) {
      // 获取了位置相关的数据
      console.log(positionData);
    });
  }
}
```


解决的方法：


1.不推荐，定义一个全局变量，执行getPostion函数后，在getPosition内部将获取的地理位置数据赋值给全局变量，在外部使用setTimeout隔一定时间段获取之前定义的全局变量，在此就能通过全局变量获得地理位置数据了；


2.常规做法，直接在获取位置数据后在回调函数内部执行接下来的操作


```javascript
const toolItemAction = document.querySelector("#tool-bottom");
toolItemAction.addEventListener('click', toolItemActionFunction);

function toolItemActionFunction() {
  getPostion();

  function getPostion() {
    navigator.geolocation.getCurrentPosition(function (positionData) {
      // 获取了位置相关的数据
      console.log(positionData);
      // 获取位置数据后进行位置分析
      console.log("接下来的位置判断操作");
    });
  }
}
```


3.更好看的解决方法，看起来更直观，但实际上和在回调函数内部执行类似；即使用promise后在then内将位置数据取到；即过程发生在promise内，结果发生在then内。


```javascript
const toolItemAction = document.querySelector("#tool-bottom");
toolItemAction.addEventListener('click', toolItemActionFunction);

function toolItemActionFunction() {
  // 位置获取后分析显示
  const actionWay = new Promise(getPostion)
  .then(function (data) {
    // 获取了位置相关的数据
    console.log(data);
    // 获取位置数据后进行位置分析
    console.log("接下来的位置判断操作");
  })

  function getPostion(resolve) {
    navigator.geolocation.getCurrentPosition(function (positionData) {
      // 用resolve将位置相关的数据传出去
      resolve(positionData);
    });
  }
}
```


优化后


```javascript
const toolItemAction = document.querySelector("#tool-bottom");
toolItemAction.addEventListener('click', toolItemActionFunction);

function toolItemActionFunction() {
  // 位置获取后分析显示
  const actionWay = new Promise(getPostion)
  .then(analysePostion)

  // 获取位置
  function getPostion(resolve) {
    navigator.geolocation.getCurrentPosition(function (positionData) {
      resolve(positionData);
    });
  }

  // 位置分析
  function analysePostion(data) {
    console.log(data);
  }
}
```


后续将总结promise有关使用……


iii：位置获取相关完整代码


```html
<!--
 * @Author: your name
 * @Date: 2021-10-05 09:43:31
 * @LastEditTime: 2021-10-05 14:07:12
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /arcgis api test/position/process/get-and-analyse-position.html
-->

<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>位置获取、位置判断</title>
  <link rel="stylesheet" href="https://js.arcgis.com/4.21/esri/themes/light/main.css" />
  <script src="https://js.arcgis.com/4.21/"></script>
  <style>
    body,
    html {
      width: 100%;
      height: 100%;
    }

    body,
    html,
    div {
      margin: 0;
      padding: 0;
    }

    #viewDiv {
      width: 100%;
      height: 100%;
    }

    #tool-bottom {
      width: 100%;
      height: 10%;
      background-color: #a23;
      position: absolute;
      bottom: 0;
      left: 0;
      color: white;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
  </style>
</head>

<body>
  <div id="viewDiv"></div>
  <div id="tool-bottom">定位分析</div>
  <script>
    require([
      "esri/Map",
      "esri/Graphic",
      "esri/views/MapView",
      "esri/layers/FeatureLayer"
    ], (Map, Graphic, MapView, FeatureLayer) => {
      const map = new Map({
        basemap: "gray-vector",
      });

      const view = new MapView({
        container: "viewDiv",
        map: map,
        center: [116.026835445288, 28.68327087208513],
        zoom: 15
      });

      // 获取定位分析所在的html节点
      const toolItemAction = document.querySelector("#tool-bottom");
      // 绑定点击事件
      toolItemAction.addEventListener('click', toolItemActionFunction);

      function toolItemActionFunction() {
        const actionWay = new Promise(getPostion)
          .then(analysePostion)

        // 获取位置
        function getPostion(resolve) {
          navigator.geolocation.getCurrentPosition(function (positionData) {
            resolve(positionData);
          });
        }

        // 位置分析
        function analysePostion(data) {
          console.log(data);
        }
      }
    });
  </script>
</body>

</html>
```
​

位置获取显示结果：浏览器右侧控制台为获取的地理位置相关的对象内容
![2-1 位置获取显示结果.png](https://cdn.nlark.com/yuque/0/2021/png/22408012/1633532397532-6071f8bf-f3af-40eb-8b77-c22bf69c8361.png#clientId=u633f0849-afb5-4&from=drop&id=u5e6200dc&margin=%5Bobject%20Object%5D&name=2-1%20%E4%BD%8D%E7%BD%AE%E8%8E%B7%E5%8F%96%E6%98%BE%E7%A4%BA%E7%BB%93%E6%9E%9C.png&originHeight=2240&originWidth=3584&originalType=binary&ratio=1&size=1378706&status=done&style=none&taskId=u81f54c1a-0eeb-4a2a-b152-bd753bad2dd)
在线预览：[get-position.html](https://pkcile.gitee.io/get-and-analyse-position/process/get-position.html)
​

#### 2.位置判断相关的扩展


概述：[FeatureLayer](https://developers.arcgis.com/javascript/latest/api-reference/esri-layers-FeatureLayer.html)图层提供了查询相关的功能；主要包含的内容，FeatureLayer图层的创建、FeatureLayer图层的扩展显示、FeatureLayer图层相关的查询方法三部分内容来进行演示；


介绍完FeatureLayer图层的创建使用相关的属性方法后，将介绍位置判断的思路。


##### 1.FeatureLayer图层的创建


i：以arcgis server、arcgis online发布服务的方式
​

```javascript
// 创建FeaureLayer图层
const featureLayerByMapServer = new FeatureLayer({
  url: "https://sampleserver6.arcgisonline.com/arcgis/rest/services/Census/MapServer/3"
});
// 创建FeaureLayer图层
const featureLayerByFeatureServer = new FeatureLayer({
  url: "https://services5.arcgis.com/tMUv40jPkGf3F4zc/arcgis/rest/services/testpoint/FeatureServer/0"
})
map.add(featureLayerByMapServer);			// 加载显示图层
map.add(featureLayerByFeatureServer)  // 加载显示图层
```
​

两种FeatureLayer加载方式添加到地图上的显示效果：
![2-2 两种FeatureLayer加载方式添加到地图上的显示效果.png](https://cdn.nlark.com/yuque/0/2021/png/22408012/1633532600748-780c386d-c0d1-4bbf-ba59-806a080f1953.png#clientId=u633f0849-afb5-4&from=drop&id=u44fb5063&margin=%5Bobject%20Object%5D&name=2-2%20%E4%B8%A4%E7%A7%8DFeatureLayer%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F%E6%B7%BB%E5%8A%A0%E5%88%B0%E5%9C%B0%E5%9B%BE%E4%B8%8A%E7%9A%84%E6%98%BE%E7%A4%BA%E6%95%88%E6%9E%9C.png&originHeight=2240&originWidth=3584&originalType=binary&ratio=1&size=852279&status=done&style=none&taskId=ueb4e0fe6-df5b-4bcd-a787-8e2cfc90c5b)
在线预览：
​

ii：Graphic（点、线、面）转换为 FeatureLayer


Graphic图形可以直接转换为FeatureLayer图层，**Graphic还需要满足的条件**：


Graphic图层**要设置attributes属性**，一般attributes有个要有的属性OBJECTID，用来唯一标识元素；


Graphic图层和FeatureLayer图层都可以添加显示在地图上，Graphic的样式由symbol属性决定；FeatureLayer的要素样式由renderer属性决定、标注符号样式由labelingInfo属性决定。


```javascript
// 模拟添加1个打卡点位

// 1.创建点Graphic图形
const pointPreparesSymbol = {
  type: "simple-marker",
  color: [255, 0, 0],
  size: 20,
  outlilne: {
    color: [255, 255, 255],
    width: 1
  }
}
const pointPreparesGraphic = new Graphic({
  geometry: {
    type: "point",
    longitude: 116.02395252668839,
    latitude: 28.68459166902746
  },
  symbol: pointPreparesSymbol,
  attributes: {
    url: "https://baidu.com",
    OBJECTID: 1
  }
});

// 2.将点Graphic转换为FeatureLayer图层
const pointPrepareLables = {
  symbol: {
    type: "text",
    color: "#FFFFFF",
    haloColor: "#f00",
    haloSize: "5px",
    font: {
      size: "20px"
    }
  },
  labelPlacement: "above-center",
  labelExpressionInfo: {
    expression: "$feature.OBJECTID + '测试点位'"
  }
};
const pointPreparesFeatureLayer = new FeatureLayer({
  source: [pointPreparesGraphic],
  fields: [
    {
      name: "OBJECTID",
      type: "oid"
    },
    {
      name: "url",
      type: "string"
    }
  ],
  objectIdField: "OBJECTID",
  geometryType: "point",
  labelingInfo: [pointPrepareLables]
});

// 3.添加显示该点的FeatureLayer图层
map.add(pointPreparesFeatureLayer);
```
​

由Graphic点创建的点的FeatureLayer图层效果：
![2-3 由Graphic点创建的点的FeatureLayer图层.png](https://cdn.nlark.com/yuque/0/2021/png/22408012/1633533086321-8d94b0cf-b0ee-46d1-9c25-0e7d1a60383e.png#clientId=u633f0849-afb5-4&from=drop&id=uffb26010&margin=%5Bobject%20Object%5D&name=2-3%20%E7%94%B1Graphic%E7%82%B9%E5%88%9B%E5%BB%BA%E7%9A%84%E7%82%B9%E7%9A%84FeatureLayer%E5%9B%BE%E5%B1%82.png&originHeight=2240&originWidth=3584&originalType=binary&ratio=1&size=1525463&status=done&style=none&taskId=u36f2397e-6d43-4d68-97eb-0c3817430b5)
在线预览：
​

##### 2.FeatureLayer图层的样式、标注、弹窗提示相关的属性


FeatureLayer创建，设置标柱样式、要素样式、弹窗提示属性；


```javascript
// 1.添加FeatureLayer图层
const featureLayerByFeatureServer = new FeatureLayer({
  url: "https://services5.arcgis.com/tMUv40jPkGf3F4zc/arcgis/rest/services/testpoint/FeatureServer/0"
});
map.add(featureLayerByFeatureServer);

// 2.标注样式设置，设置labelingInfo相关的属性
const featureLayerByFeatureServerLabel = {
  symbol: {
    type: "text",
    color: "#FFFFFF",
    haloColor: "#f00",
    haloSize: "5px",
    font: {
      size: "20px"
    }
  },
  labelPlacement: "above-center",
  labelExpressionInfo: {
    expression: "$feature.OBJECTID + '测试点位'"
  }
};
featureLayerByFeatureServer.labelingInfo = [featureLayerByFeatureServerLabel];

// 3.要素样式设置，设置renderer属性
const featureLayerByFeatureServerRenderer = {
  "type": "simple",
  "symbol": {
    "type": "picture-marker",
    "url": "http://static.arcgis.com/images/Symbols/NPS/npsPictograph_0231b.png",
    "width": "20px",
    "height": "20px"
  }
};
featureLayerByFeatureServer.renderer = featureLayerByFeatureServerRenderer;

// 4.弹窗设置，设置popupTemplate属性
const featureLayerByFeatureServerPopup = {
  "title": "标题",
  "content": "<b>feature属性:</b> {ObjectId}<br>弹窗设置"
}
featureLayerByFeatureServer.popupTemplate = featureLayerByFeatureServerPopup;
```
​

featureLayer样式设置显示效果：
![2-7 featureLayer样式设置显示效果.png](https://cdn.nlark.com/yuque/0/2021/png/22408012/1633533581648-033b04f0-926f-4a0f-a831-356375fc7e65.png#clientId=u633f0849-afb5-4&from=drop&id=uea42c174&margin=%5Bobject%20Object%5D&name=2-7%20featureLayer%E6%A0%B7%E5%BC%8F%E8%AE%BE%E7%BD%AE%E6%98%BE%E7%A4%BA%E6%95%88%E6%9E%9C.png&originHeight=2240&originWidth=3584&originalType=binary&ratio=1&size=1365880&status=done&style=none&taskId=ubf888a10-3bcd-409e-9a86-8c32e12dbb1)
在线预览：featureLayer-point-label-feature-style.html
​

如想设置某个属性直接在[arcgis js api官网文档](https://developers.arcgis.com/javascript/latest/api-reference/)搜索即可，如搜索labelingInfo属性
![2-4 搜索labelingInfo属性.png](https://cdn.nlark.com/yuque/0/2021/png/22408012/1633533213471-2a1e138f-2e0f-462a-814c-dd31e570a372.png#clientId=u633f0849-afb5-4&from=drop&id=u2f7bd77e&margin=%5Bobject%20Object%5D&name=2-4%20%E6%90%9C%E7%B4%A2labelingInfo%E5%B1%9E%E6%80%A7.png&originHeight=2240&originWidth=3584&originalType=binary&ratio=1&size=906270&status=done&style=none&taskId=ubb59e610-8102-4cf2-9031-70117bf7fe0)


查找定位到对应的labelingInfo属性
![2-5 查找定位到对应的labelingInfo属性.png](https://cdn.nlark.com/yuque/0/2021/png/22408012/1633533261963-84a7d504-c20b-46cf-a0d3-c6dd042a4756.png#clientId=u633f0849-afb5-4&from=drop&id=u4ccd859c&margin=%5Bobject%20Object%5D&name=2-5%20%E6%9F%A5%E6%89%BE%E5%AE%9A%E4%BD%8D%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84labelingInfo%E5%B1%9E%E6%80%A7.png&originHeight=2240&originWidth=3584&originalType=binary&ratio=1&size=903233&status=done&style=none&taskId=u48bf73bb-4820-4998-b7d8-e70456a1d2b)
​

扩展：Graphic图像的点、线、面符号样式对应可设置的符号类型[symbol types](https://developers.arcgis.com/javascript/latest/api-reference/esri-symbols-Symbol.html)![截屏2021-10-05 下午6.05.10.png](https://cdn.nlark.com/yuque/0/2021/png/22408012/1633533288308-16aab914-544f-4456-b99c-734dd919ae80.png#clientId=u633f0849-afb5-4&from=drop&id=u953f035a&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-10-05%20%E4%B8%8B%E5%8D%886.05.10.png&originHeight=1358&originWidth=2216&originalType=binary&ratio=1&size=329549&status=done&style=none&taskId=u4ba50e2c-4e6b-4521-bae7-12f52e1e0d9)
​

3.FeatureLayer图层的查询、展示相关的方法


FeatureLayer相关的查询相关的方法，首先最重要的是查询条件创建方法createQuery和要素查询方法queryFeatures；更多FeatureLayer相关方法的使用可参照[官网](https://developers.arcgis.com/javascript/latest/api-reference/esri-layers-FeatureLayer.html#methods-summary)，根据使用需求查找。


FeatureLayer图层要素作为被查询对象时，最常用的是createQuery、queryFeatures结合使用，createQuery可设置查询的属性和空间位置等信息，queryFeatures来展示查询的要素结果数据。


i：一个完整的属性、空间位置查询案例；


```html
<!--
 * @Author: your name
 * @Date: 2021-10-05 15:08:48
 * @LastEditTime: 2021-10-06 09:19:04
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /arcgis api test/position/process/feature.html
-->

<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>位置获取、位置判断</title>
  <link rel="stylesheet" href="https://js.arcgis.com/4.21/esri/themes/light/main.css" />
  <script src="https://js.arcgis.com/4.21/"></script>
  <style>
    body,
    html {
      width: 100%;
      height: 100%;
    }

    body,
    html,
    div {
      margin: 0;
      padding: 0;
    }

    #viewDiv {
      width: 100%;
      height: 100%;
    }
  </style>
</head>

<body>
  <div id="viewDiv"></div>
  <script>
    require([
      "esri/Map",
      "esri/Graphic",
      "esri/views/MapView",
      "esri/layers/FeatureLayer"
    ], (Map, Graphic, MapView, FeatureLayer) => {
      const map = new Map({
        basemap: "gray-vector",
      });

      const view = new MapView({
        container: "viewDiv",
        map: map,
        center: [116.026835445288, 28.68327087208513],
        zoom: 15 
      });
      
      // 1.添加FeatureLayer图层
      const featureLayerByFeatureServer = new FeatureLayer({
        url: "https://services5.arcgis.com/tMUv40jPkGf3F4zc/arcgis/rest/services/testpoint/FeatureServer/0"
      });
      map.add(featureLayerByFeatureServer);

      // 2.查询的空间位置条件，一个geometry点
      const geometry001 =  {
          type: "point",
          longitude: 116.02395252668839,
          latitude: 28.68459166902746
      };

      // 3.FeatureLayer图层被查询条件设置
      // 设置查询条件
      const queryParams = featureLayerByFeatureServer.createQuery();
      // queryParams.where = "CITY_JUR = 'Malibu'";
      queryParams.geometry = geometry001;
      queryParams.spatialRelationship = "intersects";
      queryParams.units = "meters";
      queryParams.distance = 400;
      queryParams.returnQueryGeometry = true;
      queryParams.returnGeometry = true;

      // 4.查询结果
      featureLayerByFeatureServer.queryFeatures(queryParams).then(function (results) {
        console.log(results);
      });
    });
  </script>
</body>

</html
```


结果：在浏览器控制台即可看到查询结果对象，该对象的features属性表示查询到的元素、queryGeometry属性表示用来查询的图形的geometry或图形根据缓冲半径生成的多边形的geometry。
​

简单的featureLayer图层查询结果：
![截屏2021-10-05 下午10.53.17.png](https://cdn.nlark.com/yuque/0/2021/png/22408012/1633533797399-4eb37366-b9d1-4f6b-bb88-557ee5eee094.png#clientId=u633f0849-afb5-4&from=drop&id=u99f3076b&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-10-05%20%E4%B8%8B%E5%8D%8810.53.17.png&originHeight=2240&originWidth=3584&originalType=binary&ratio=1&size=1527589&status=done&style=none&taskId=u297c32d5-ad89-4425-b65a-067fdab4ebf)
在线预览：featureLayer-query-start.html
​

**1.创建FeatureLayer图层：**本案例中，创建FeatureLayer图层直接使用FeatureServer服务来创建；FeatureServer服务可在[arcgis开发者平台](https://developers.arcgis.com/layers)上传使用


数据发布需要注意的内容：


1.若是shp类型的矢量数据尽量将其通过QGIS等软件将shp文件转换为geojson格式的；


2.每一次上传矢量文件后，填写的title名称不要和之前的title名称相同。


**2.创建查询的空间位置信息：**geometry可以是点、线、面


geometry类型点、线、面的创建


```javascript
const geometryPoint = {
  type: "point",
  longitude: 116.02395252668839,
  latitude: 28.68459166902746
};

const geometryLine = {
  type: "polyline",
  paths: [[-111.3, 52.68], [-98, 49.5], [-93.94, 29.89]]
}

const geometryPolygon = {
  type: "polygon",
  rings: [[-64.78, 32.3], [-66.07, 18.45], [-80.21, 25.78], [-64.78, 32.3]]
}
```


geometry类型点作为Graphic类型点添加显示：


```javascript
const geometryPoint = {
  type: "point",
  longitude: 116.02395252668839,
  latitude: 28.68459166902746
};

const pointGraphic = new Graphic({
  geometry: geometryPoint,
  symbol: {
    type: "simple-marker",
    size: "30px",
    color: [226, 119, 40],
    outline: {
      color: [255, 255, 255],
      width: 2
    }
  }
});

view.graphics.add(pointGraphic);
```


**3.查询条件设置：**可设置位置查询参数如地理要素、查询关系、缓冲单位、缓冲数量（geometry、spatialRelationship、units、distance）等信息；设置returnQueryGeometry属性为true可返回用来查询的图形的geometry或图形根据缓冲半径生成的多边形的geometry；


同时也可以在查询参数中设置where属性，进而限制被查询的FeatureLayer图层要素的属性信息。


```javascript
const queryParams = featureLayerByFeatureServer.createQuery();
// queryParams.where = "CITY_JUR = 'Malibu'";
queryParams.geometry = geometry001;
queryParams.spatialRelationship = "intersects";
queryParams.units = "meters";
queryParams.distance = 400;
queryParams.returnQueryGeometry = true;
queryParams.returnGeometry = true;
```


**4.获取查询结果：**


利用FeatureLayer的queryGeometry方法来查询获取到满足查询条件的要素结果。


```javascript
featureLayerByFeatureServer.queryFeatures(queryParams).then(function (results) {
	console.log(results);
});
```


其中查询到的结果results对象的属性信息：


```javascript
results.features							// 查询到的元素内容
results.returnQueryGeometry		// 查询的图形的geometry或图形根据缓冲半径生成的多边形的geometry
```


ii：优化显示该属性、空间位置查询案例，完整代码为；


```html
<!--
 * @Author: your name
 * @Date: 2021-10-06 09:22:51
 * @LastEditTime: 2021-10-06 18:31:32
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /position/process/query01.html
-->

<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>位置获取、位置判断</title>
  <link rel="stylesheet" href="https://js.arcgis.com/4.21/esri/themes/light/main.css" />
  <script src="https://js.arcgis.com/4.21/"></script>
  <style>
    body,
    html {
      width: 100%;
      height: 100%;
    }

    body,
    html,
    div {
      margin: 0;
      padding: 0;
    }

    #viewDiv {
      width: 100%;
      height: 100%;
    }
/* 
    #tool-bottom {
      width: 100%;
      height: 10%;
      background-color: #a23;
      position: absolute;
      bottom: 0;
      left: 0;
      color: white;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
    } */
  </style>
</head>

<body>
  <div id="viewDiv"></div>
  <!-- <div id="tool-bottom">定位分析</div> -->
  <script>
    require([
      "esri/Map",
      "esri/Graphic",
      "esri/views/MapView",
      "esri/layers/FeatureLayer"
    ], (Map, Graphic, MapView, FeatureLayer) => {
      const map = new Map({
        basemap: "gray-vector",
      });

      const view = new MapView({
        container: "viewDiv",
        map: map,
        center: [116.026835445288, 28.68327087208513],
        zoom: 15 
      });
      
      // 1.添加FeatureLayer图层
      const featureLayerByFeatureServer = new FeatureLayer({
        url: "https://services5.arcgis.com/tMUv40jPkGf3F4zc/arcgis/rest/services/testpoint/FeatureServer/0"
      });
      map.add(featureLayerByFeatureServer);

      // 2.查询的空间位置条件，一个geometry点；设置查询元素的样式
      const geometryPoint =  {
          type: "point",
          longitude: 116.02395252668839,
          latitude: 28.68459166902746
      };
      
      // 查询要素点的设置
      const pointGraphic = new Graphic({
        geometry: geometryPoint,
        symbol: {
          type: "simple-marker",
          size: "30px",
          color: [226, 119, 40],
          outline: {
            color: [255, 255, 255],
            width: 2
          }
        }
      });
      view.graphics.add(pointGraphic);

      // 查询要素点缓冲后的多边形要素的设置
      const polygonQueryGraphic = new Graphic({
        symbol:  {
          type: "simple-fill", 
          color: [255, 255, 255, 0.2],
          outline: {
            color: [0, 0, 255],
            width: 2
          }
        }
      });

      // 3.FeatureLayer图层被查询条件设置
      // 设置查询条件
      const queryParams = featureLayerByFeatureServer.createQuery();
      // queryParams.where = `name = '测试点1'`;
      queryParams.geometry = geometryPoint;
      queryParams.spatialRelationship = "intersects";
      queryParams.units = "meters";
      queryParams.distance = 600;
      queryParams.returnQueryGeometry = true;
      queryParams.returnGeometry = true;

      // 4.查询结果
      featureLayerByFeatureServer.queryFeatures(queryParams).then(function (results) {
        console.log(results);
        // 显示查询要素点缓冲后的多边形要素
        polygonQueryGraphic.geometry = results.queryGeometry;
        view.graphics.add(polygonQueryGraphic);

        // 显示被查询到的点要素
        results.features.forEach(function(item) {
          const pointQueriedGraphic = new Graphic({
              symbol: {
                type: "simple-marker",
                size: "15px",
                color: [0, 0, 255],
                outline: {
                  color: [255, 255, 255],
                  width: 2
                }
              }
            });
          pointQueriedGraphic.geometry = item.geometry;
          view.graphics.add(pointQueriedGraphic);
        });
      });
    });
  </script>
</body>

</html
```
​

样式完善后的查询显示结果：
![截屏2021-10-06 下午6.36.36.png](https://cdn.nlark.com/yuque/0/2021/png/22408012/1633533962926-187356c5-7c42-47bd-a302-883e48c7035e.png#clientId=u633f0849-afb5-4&from=drop&id=uaa47b78b&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-10-06%20%E4%B8%8B%E5%8D%886.36.36.png&originHeight=2240&originWidth=3584&originalType=binary&ratio=1&size=1883922&status=done&style=none&taskId=u29ad2edc-b993-43b6-95c4-f8421bb5bf5)
在线预览：featureLayer-query-style.html
​

iii：FeathureLayer相关的查询方法的使用
​

部分代码


```javascript
// 查询符合queryParams条件的要素
featureLayerByFeatureServer.queryFeatures(queryParams).then(function (results) {
  console.log(results);
});

// 查询全部要素
featureLayerByFeatureServer.queryFeatures().then(function(results) {
  console.log(results);
});

// 查询符合queryParams条件的要素个数
featureLayerByFeatureServer.queryFeatureCount().then(function(resultsNumber) {
  console.log(resultsNumber);
});

// 查询符合queryParams条件的要素个数
featureLayerByFeatureServer.queryFeatureCount(queryParams).then(function (resultsNumber) {
  console.log(resultsNumber);
})
```


完整代码


```javascript
<!--
 * @Author: your name
 * @Date: 2021-10-06 09:22:51
 * @LastEditTime: 2021-10-06 18:53:33
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /position/process/query01.html
-->

<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>位置获取、位置判断</title>
  <link rel="stylesheet" href="https://js.arcgis.com/4.21/esri/themes/light/main.css" />
  <script src="https://js.arcgis.com/4.21/"></script>
  <style>
    body,
    html {
      width: 100%;
      height: 100%;
    }

    body,
    html,
    div {
      margin: 0;
      padding: 0;
    }

    #viewDiv {
      width: 100%;
      height: 100%;
    }

    /* 
    #tool-bottom {
      width: 100%;
      height: 10%;
      background-color: #a23;
      position: absolute;
      bottom: 0;
      left: 0;
      color: white;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
    } */
  </style>
</head>

<body>
  <div id="viewDiv"></div>
  <!-- <div id="tool-bottom">定位分析</div> -->
  <script>
    require([
      "esri/Map",
      "esri/Graphic",
      "esri/views/MapView",
      "esri/layers/FeatureLayer"
    ], (Map, Graphic, MapView, FeatureLayer) => {
      const map = new Map({
        basemap: "gray-vector",
      });

      const view = new MapView({
        container: "viewDiv",
        map: map,
        center: [116.026835445288, 28.68327087208513],
        zoom: 15
      });

      // 1.添加FeatureLayer图层
      const featureLayerByFeatureServer = new FeatureLayer({
        url: "https://services5.arcgis.com/tMUv40jPkGf3F4zc/arcgis/rest/services/testpoint/FeatureServer/0"
      });
      map.add(featureLayerByFeatureServer);

      // 2.查询的空间位置条件，一个geometry点；设置查询元素的样式
      const geometryPoint = {
        type: "point",
        longitude: 116.02395252668839,
        latitude: 28.68459166902746
      };

      // 查询要素点的设置
      const pointGraphic = new Graphic({
        geometry: geometryPoint,
        symbol: {
          type: "simple-marker",
          size: "30px",
          color: [226, 119, 40],
          outline: {
            color: [255, 255, 255],
            width: 2
          }
        }
      });
      view.graphics.add(pointGraphic);

      // 查询要素点缓冲后的多边形要素的设置
      const polygonQueryGraphic = new Graphic({
        symbol: {
          type: "simple-fill",
          color: [255, 255, 255, 0.2],
          outline: {
            color: [0, 0, 255],
            width: 2
          }
        }
      });

      // 3.FeatureLayer图层被查询条件设置
      // 设置查询条件
      const queryParams = featureLayerByFeatureServer.createQuery();
      // queryParams.where = `name = '测试点1'`;
      queryParams.geometry = geometryPoint;
      queryParams.spatialRelationship = "intersects";
      queryParams.units = "meters";
      queryParams.distance = 600;
      queryParams.returnQueryGeometry = true;
      queryParams.returnGeometry = true;

      // 4.查询结果
      // 查询符合queryParams条件的要素
      featureLayerByFeatureServer.queryFeatures(queryParams).then(function (results) {
        console.log(results);
        // 显示查询要素点缓冲后的多边形要素
        polygonQueryGraphic.geometry = results.queryGeometry;
        view.graphics.add(polygonQueryGraphic);

        // 显示被查询到的点要素
        results.features.forEach(function (item) {
          const pointQueriedGraphic = new Graphic({
            symbol: {
              type: "simple-marker",
              size: "15px",
              color: [0, 0, 255],
              outline: {
                color: [255, 255, 255],
                width: 2
              }
            }
          });
          pointQueriedGraphic.geometry = item.geometry;
          view.graphics.add(pointQueriedGraphic);
        });
      });
      
      // 查询全部要素
      featureLayerByFeatureServer.queryFeatures().then(function(results) {
        console.log(results);
      });

      // 查询符合queryParams条件的要素个数
      featureLayerByFeatureServer.queryFeatureCount().then(function(resultsNumber) {
        console.log(resultsNumber);
      });

      // 查询符合queryParams条件的要素个数
      featureLayerByFeatureServer.queryFeatureCount(queryParams).then(function (resultsNumber) {
        console.log(resultsNumber);
      })
      
    });

  </script>
</body>

</html
```


#### 3.位置判断相关的思路过程


##### 1.思路概述：
位置获取一个坐标点后，将坐标点转换为geomety点类型并作为位置查询条件；geomety点、featureLayer的属性限制作为查询条件来查询featureLayer图层是否有满足条件的要素，如果能查询到featureLayer图层的要素，则位置获取的坐标点满足条件因此位置判断成功。
​

次要工作：可视化位置获取的坐标点、可视化经要素图层查询获取的坐标点位的缓冲多边形、可视化要素图层被查询到的要素。


##### 2.完整代码：


```html
<!--
 * @Author: your name
 * @Date: 2021-10-04 14:53:22
 * @LastEditTime: 2021-10-06 19:12:18
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /arcgis api test/position/get-and-analyse-position.html
-->

<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <link rel="stylesheet" href="https://js.arcgis.com/4.21/esri/themes/light/main.css" />
  <script src="https://js.arcgis.com/4.21/"></script>
  <style>
    body,
    html {
      width: 100%;
      height: 100%;
    }

    body,
    html,
    div {
      margin: 0;
      padding: 0;
    }

    #viewDiv {
      width: 100%;
      height: 100%;
    }

    #tool-bottom {
      width: 100%;
      height: 10%;
      background-color: #a23;
      position: absolute;
      bottom: 0;
      left: 0;
      color: white;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
  </style>
</head>

<body>
  <div id="viewDiv"></div>
  <div id="tool-bottom">定位分析</div>
  <script>
    require([
      "esri/Map",
      "esri/Graphic",
      "esri/views/MapView",
      "esri/layers/FeatureLayer"
    ], (Map, Graphic, MapView, FeatureLayer) => {
      const map = new Map({
        basemap: "gray-vector",
      });

      const view = new MapView({
        container: "viewDiv",
        map: map,
        center: [116.026835445288, 28.68327087208513],
        zoom: 15
      });

      view.on('click', (data) => {
        console.log(data);
      });

      const toolItemAction = document.querySelector("#tool-bottom");
      toolItemAction.addEventListener('click', toolItemActionFunction);

      function toolItemActionFunction() {
        const actionWay = new Promise(getPostion)
          .then(analysePostion)

        // 位置获取
        function getPostion(resolve) {
          // console.log(arguments);
          navigator.geolocation.getCurrentPosition(function (positionData) {
            resolve(positionData);
          });
        }
        // 位置分析
        function analysePostion(data) {
          // 显示定位的坐标点
          const pointPosition = {
            type: "point",
            longitude: data.coords.longitude,
            latitude: data.coords.latitude
          };
          const markerPositionSymbol = {
            type: "simple-marker",
            color: [226, 119, 40],
            outline: {
              color: [255, 255, 255],
              width: 2
            }
          };
          const pointPositionGraphic = new Graphic({
            geometry: pointPosition,
            symbol: markerPositionSymbol
          });
          view.graphics.add(pointPositionGraphic);

          // 模拟添加几个打卡点位
          const pointPrepares = [
            {
              type: "point",
              longitude: 116.02395252668839,
              latitude: 28.68459166902746
            },
            {
              type: "point",
              latitude: 28.685976700257267,
              longitude: 116.0218080439376
            },
            {
              type: "point",
              latitude: 28.684471360531717,
              longitude: 116.02925925463262
            }
          ]
          const pointPreparesSymbol = {
            type: "simple-marker",
            color: [255, 0, 0],
            outlilne: {
              color: [255, 255, 255],
              width: 1
            }
          }
          const pointPreparesGraphics = [];
          pointPrepares.forEach((item, index) => {
            // console.log(index);
            pointPreparesGraphics.push(
              new Graphic({
                geometry: item,
                symbol: pointPreparesSymbol,
                attributes: {        
                  url: "https://baidu.com",
                  OBJECTID: index
                }
              })
            );
          });

          // 将模拟添加几个打卡点位生成feature图层
          const pointPrepareLables = {
            symbol: {
              type: "text",
              color: "#FFFFFF",
              haloColor: "#f00",
              haloSize: "5px",
              font: {
                size: "18px",
                // family: "Noto Sans",
                // style: "italic",
                // weight: "normal"
              }
            },
            labelPlacement: "above-center",
            labelExpressionInfo: {
              expression: "$feature.OBJECTID + '测试点位'"
            }
          };
          const pointPreparesFeatureLayer = new FeatureLayer({
            source: pointPreparesGraphics,
            fields: [
              {
                name: "OBJECTID",
                type: "oid"
              },
              {
                name: "url",
                type: "string"
              }
            ],
            objectIdField: "OBJECTID",
            geometryType: "point",
            labelingInfo: [pointPrepareLables]
          });
          map.add(pointPreparesFeatureLayer);

          // 预设缓冲区域样式
          const bufferSymbol = {
            type: "simple-fill", // autocasts as new SimpleFillSymbol()
            color: [255, 255, 255, 0.2],
            outline: {
              // autocasts as new SimpleLineSymbol()
              color: [227, 139, 79],
              width: 1
            }
          }
          const bufferGraphic = {
            symbol: bufferSymbol
          };

          // 预设被查询到的点位样式
          const querySymbol = {
            type: "simple-marker",
            color: [0, 0, 255],
            outline: {
              color: [255, 255, 255],
              width: 1
            }
          };
          const queryGraphics = [];
          
          // 查询：空间查询和属性查询
          const queryParams = pointPreparesFeatureLayer.createQuery();
          // queryParams.where = "CITY_JUR = 'Malibu'";
          queryParams.geometry = pointPositionGraphic.geometry;
          queryParams.spatialRelationship = "intersects";
          queryParams.units = "meters";
          queryParams.distance = 400;
          queryParams.returnQueryGeometry = true;
          queryParams.returnGeometry = true;
          pointPreparesFeatureLayer.queryFeatures(queryParams).then(function (results) {
            console.log(results.features);
            bufferGraphic.geometry = results.queryGeometry;
            view.graphics.add(bufferGraphic);
            
            results.features.forEach((item) => {
              queryGraphics.push(
                new Graphic({
                  geometry: item.geometry,
                  symbol: querySymbol
                })
              );
          });
          view.graphics.addMany(queryGraphics);
            // pointPreparesFeatureLayer.labelsVisible = false;
          });
          // console.log(pointPreparesFeatureLayer);
        }

      }
    });
  </script>
</body>

</html>
```
​

最终的位置获取、判断显示的显示效果：
![截屏2021-10-06 下午4.55.14.png](https://cdn.nlark.com/yuque/0/2021/png/22408012/1633534153647-869f21c0-e1aa-496b-967f-5fbc158d47d9.png#clientId=u633f0849-afb5-4&from=drop&id=u01ea99b1&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-10-06%20%E4%B8%8B%E5%8D%884.55.14.png&originHeight=2240&originWidth=3584&originalType=binary&ratio=1&size=1282592&status=done&style=none&taskId=uc38a8f80-2d5a-45ae-a5a8-be0f3fa28f2)
在线预览-featuerLayer由Graphic创建：get-and-analyse-position1.html
在线预览-featuerLayer由Map Server或Feature Server创建：get-and-analyse-position2.html
​

##### 3.遇到的异常情况和解决方法：
异常情况：在实际使用过程中，使用arcgis server发布的Map Server服务生成的featureLayer要素图层，该featureLayer要素图层不能与geomety点类型并作为位置查询条件设置并返回缓冲区域。
简单的讲：由服务创建的featureLayer要素图层设置查询条件**有时**会存在不能设置geometry点的缓冲半径参数的问题。
解决方法：由Graphic创建的featureLayer要素图层一定能设置geometry点的缓冲半径参数。
可由随意创建的点、线或面Graphic创建的featureLayer要素图层，设置查询条件时，设置获取的位置geometry点的缓冲半径参数，查询结果中将返回点缓冲后的图形的geometry；由第一次查询获取到的点缓冲后的图形的geometry作为第二次的位置查询条件，真正要被查询的图层为由Map Server或Feature Server创建的要素图层。
解决方法示例：
```javascript
<!--
 * @Author: your name
 * @Date: 2021-10-03 15:58:55
 * @LastEditTime: 2021-10-09 19:46:35
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /arcgis api test/queryFeature.html
-->

<html>

<head>
  <meta name="description" content="DevLab: Configure a popup">
  <meta charset="utf-8">
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
  <title>ArcGIS API for JavaScript Tutorials: Display a pop-up (JSAPI)</title>
  <style>
    html,
    body,
    #viewDiv {
      padding: 0;
      margin: 0;
      height: 100%;
      width: 100%;
    }
  </style>
  <link rel="stylesheet" href="https://js.arcgis.com/4.21/esri/themes/light/main.css">
  <script src="https://js.arcgis.com/4.21/"></script>
</head>

<body>
  <div id="viewDiv"></div>
  
  <script>
    require([
      "esri/config",
      "esri/Map",
      "esri/views/MapView",

      "esri/layers/FeatureLayer",
      "esri/Graphic",
    ],

      function (esriConfig, Map, MapView, FeatureLayer, Graphic) {
        const map = new Map({
          basemap: "hybrid"
        });

        const view = new MapView({
          container: "viewDiv",
          map: map,
          center: [-118.80543, 34.02700],
          zoom: 13
        });

        // 1.设置由FeatureServer服务创建的FeatureLayer图层
        const popupTrailheads = {
          "title": "Trailhead",
          "content": "<b>Trail:</b> {TRL_NAME}<br><b>City:</b> {CITY_JUR}<br><b>Cross Street:</b> {X_STREET}<br><b>Parking:</b> {PARKING}<br><b>Elevation:</b> {ELEV_FT} ft"
        }

        const trailheadsRenderer = {
          "type": "simple",
          "symbol": {
            "type": "picture-marker",
            "url": "http://static.arcgis.com/images/Symbols/NPS/npsPictograph_0231b.png",
            "width": "12px",
            "height": "12px"
          }
        }

        const trailheadsLabels = {
          symbol: {
            type: "text",
            color: "#FFFFFF",
            haloColor: "#5E8D74",
            haloSize: "2px",
            font: {
              size: "12px",
              family: "Noto Sans",
              style: "italic",
              weight: "normal"
            }
          },

          labelPlacement: "above-center",
          labelExpressionInfo: {
            expression: "$feature.CITY_JUR"
          }
        };

        const featureLayerTrailheads = new FeatureLayer({
          url: "https://services3.arcgis.com/GVgbJbqm8hXASVYi/arcgis/rest/services/Trailheads_Styled/FeatureServer/0",
          outFields: ["TRL_NAME", "CITY_JUR", "X_STREET", "PARKING", "ELEV_FT"],
          popupTemplate: popupTrailheads,
          renderer: trailheadsRenderer,
          labelingInfo: [trailheadsLabels]
        });

        map.add(featureLayerTrailheads);


        // 2.由Graphic 线创建feathureLayer图层
        const polyline001 = {
          type: "polyline",
          paths: [[-118.81003851291077, 34.00505318210127], [-118.8021255890085, 34.00434599781676]]
        };

        const lineSymbol = {
          type: "simple-line",
          color: [226, 119, 40],
          width: 4
        };

        const lineAtt = {
          Name: "Keystone Pipeline",
          Owner: "TransCanada",
          Length: "3,456 km"
        };

        const polylineGraphic = new Graphic({
          geometry: polyline001,
          symbol: lineSymbol,
          attributes: {
            url: "https://arcgis.github.io/arcgis-samples-javascript/sample-data/featurelayer-collection/photo-1.jpg",
            OBJECTID: "1"
          },
        });

        const featureLayerLayer01 = new FeatureLayer({
          source: [polylineGraphic],
          fields: [
            {
              name: "OBJECTID",
              type: "oid"
            },
            {
              name: "url",
              type: "string"
            }
          ],
          objectIdField: "OBJECTID",
          geometryType: "polyline"
        });

        map.add(featureLayerLayer01);

        // 位置点设置
        const point = {
          type: "point",
          longitude: -118.81003851291077,
          latitude: 34.00505318210127
        };

        // 3.第一次查询设置
        const queryParams2 = featureLayerLayer01.createQuery();
        queryParams2.geometry = point;
        queryParams2.spatialRelationship = "intersects";
        queryParams2.units = "kilometers";
        queryParams2.distance = 10;
        queryParams2.returnQueryGeometry = true;
        featureLayerLayer01.queryFeatures(queryParams2).then(function (results) {
          // 查询返回的点的缓冲geometry
          console.log(results.queryGeometry);
          const queryParamsFinal = featureLayerTrailheads.createQuery();
          queryParamsFinal.geometry = results.queryGeometry;
          queryParamsFinal.spatialRelationship = "intersects";
          featureLayerTrailheads.queryFeatures(queryParamsFinal).then(function (results) {
            // 查询到的要素
            console.log(results.features);
          });
        });

      });
  </script>
</body>

</html>
```
在线预览：query-twice.html
### 三、知识点汇总：


1.CSS布局之flex推荐观看文章，该博客拿来当字典用即可


2.JavaScript之Promise的使用、循环的使用


3.arcgis地图渲染库
​

